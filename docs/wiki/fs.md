<!-- 文件系统的层次结构一篇（磁盘、块设备、分区、文件系统） -->
# 文件系统

## 导读

文件系统（File System）为操作系统提供了持久存储设备上高效管理信息的能力：其为上层应用抽象出统一的设备访问接口，屏蔽不同底层块设备的操作细节。文件系统强大而复杂，横跨计算机不同存储体系，涵盖了逻辑设计与物理实现的解耦与联系。因此，本章 Wiki 将从概念出发，逐步介绍文件系统的前世今生。

!!! note "持久存储设备"
    持久存储设备（Persistent Storage）是指计算机中用于持久化存储数据的设备。
    
    有别于易失性存储设备“内存”，持久存储设备的数据**不会因为掉电而丢失**。
    
    常见的持久存储设备包括磁盘、固态硬盘、光盘、磁带、闪存等。

要想深刻理解文件系统，首先需要了解文件与持久存储。由于计算机内存中的数据在掉电后会丢失，应用程序需要将数据保存在持久存储设备上。为了满足这个需求，计算机操作系统一般会有两种处理方法：

- 应用程序直接操作持久存储设备，自己维护数据的存储和读写。
- 应用程序通过操作系统提供的文件系统接口，由操作系统负责维护数据的存储和读写。

对于前者，由之前的学习可以知道：计算机中应用程序若要和设备直接交互，需要操作系统让渡部分设备管理权限，无形中会引入安全隐患（如侧信道攻击等）。此外，不同的设备有不同的操作模式，应用程序需要针对不同的设备编写不同的代码，增加了开发难度的同时，还降低了应用的可移植性。因此，操作系统将设备的操作细节隐藏起来，为应用程序提供了统一的设备访问接口。这些统一的用户态/内核态访问接口和对应的数据结构组成了文件系统，而文件就是对在持久化存储设备上数据块的抽象。

了解以上基本概念后，本章 Wiki 将继续介绍常见文件系统的层次结构，文件系统的实现概述以及对传统内核存储栈的讨论。 

## 文件系统的层次结构

文件系统的层次结构通常可以自上而下分为以下几个层次，每个层次负责不同的功能和任务：

1. **物理层**：物理层是文件系统最底层的部分，负责处理存储介质（即前文提到的“持久存储设备”）的读写操作。物理层将这些存储介质分割成逻辑块（例如扇区），并提供对这些块的标准化读写访问接口。

2. **块设备层**：块设备层建立在物理层之上，负责管理文件系统的逻辑块的分配和存储。它将提供了块级别的访问接口，允许文件系统在这些块上进行读写操作。典型的块设备包括硬盘分区、磁盘卷（RAID）、虚拟存储设备等。

3. **文件系统层**：文件系统层是文件系统的核心部分，负责管理文件和目录的组织、存储以及访问。它提供了一个逻辑视图，使用户和应用程序可以通过文件和目录的名称来访问数据，**而不需要关注物理存储的细节**。文件系统通常包括文件的创建、删除、修改、权限管理等功能，以及元数据的存储和管理（如文件大小、创建时间、修改时间等）。

4. **虚拟文件系统层**（可选）：虚拟文件系统层是文件系统的抽象层，负责统一管理不同类型的文件系统，并提供统一的访问接口给上层应用程序和用户。

!!! note "思考：为什么要在存储栈中额外抽象多一层接口？"

    虚拟文件系统层（VFS）可以将不同文件系统（如 FAT、NTFS、EXT4 等）**抽象成相同的接口**，使得用户和应用程序可以**统一地访问**这些不同类型的文件系统，而不用关心底层文件系统的差异。

5. **用户空间接口层**：用户空间接口层提供了用户和应用程序与文件系统之间的交互接口，使用户能够通过命令行或图形界面来操作文件和目录。这包括常见的文件操作命令（如 ls、cp、mv、rm 等）、文件管理器、API 接口等。

以上是文件系统的一般层次结构，不同的文件系统可能会有些许变化，如继续拆分某个层次、合并部分层次，但大致上都会包含类似的组成部分。


## 文件系统的实现方法

在正式介绍文件系统的实现方法之前，首先来了解一下文件系统的“松耦合”设计哲学。在操作系统的设计中，松耦合（Loose Coupling）是一种设计思路，它强调模块之间的独立性和解耦性，使得模块之间的依赖关系尽可能的减少。这种设计思路的好处是，当一个模块发生变化时，不会对其他模块产生太大的影响，从而提高了系统的可维护性和可扩展性。一个参考的具体例子如下：

> [“松耦合”设计思路（rCore）](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter6/2fs-implementation.html)
> 能做到这一点，是由于我们在 easy-fs 设计上，采用了松耦合模块化设计思路。easy-fs 与底层设备驱动之间通过抽象接口 BlockDevice 来连接，避免了与设备驱动的绑定。easy-fs 通过Rust提供的 alloc crate 来隔离了操作系统内核的内存管理，避免了直接调用内存管理的内核函数。在底层驱动上，采用的是轮询的方式访问 virtio_blk 虚拟磁盘设备，从而避免了访问外设中断的相关内核函数。easy-fs 在设计中避免了直接访问进程相关的数据和函数，从而隔离了操作系统内核的进程管理。

接下来是文件系统具体的实现方法。一般来说，设计文件系统需要仔细规划以下布局：

- **引导扇区**：对于部分启动方法（如 BIOS-x86 ）来说，引导扇区是启动时必不可少的部分，但其他启动方法（如 UEFI 和 OpenFirmware）则一般不需要保留引导扇区。虽然引导扇区是实现的可选项，但保留引导扇区能让操作系统易于被移植以使用对应的启动方法。

- **分区元数据**：这可以与引导代码一起放置在第一个扇区中，或者作为一个单独的扇区组放置在特定位置。（FAT 将其放在第一个扇区中，称为 FAT 参数块。 ext 使用一个单独的位置，称为超级块。）一般来说，元数据至少包含文件系统大小、文件表的位置和版本号。类似的，在实现时尽量留出充足的空间，以容纳初版设计没有考虑到的功能。如果放置在第一个扇区中，请不要忘记为jmp指令、引导代码和分区表等信息留出空间。

- **文件表**：不要将其简单视为保存文件位置表格。类似于页表项，文件表项也可以包含文件的元信息，如：权限、所有者、文件大小、文件位置等信息。文件表项的大小取决于文件系统的设计，但一般来说，文件表项的大小应该是固定的。文件表项的大小不应该随文件大小的增长而增长，这样可以避免在文件系统中产生碎片。

- **数据区域**：文件的真正储存位置，具体实现应与上文提及的组件相对应。

你还可以参考 [rCore - 代码导读部分](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter6/0intro.html)，学习系统代码迭代开发的过程，获得另一视角的实现参考。

## 讨论

当然，应用程序（用户态）直接与持久存储设备交互的模式也不是绝对的缺点。在传统的设计（如 Linux）中，应用程序的存储栈往往由以下数个部分组成：用户态逻辑-系统调用-虚拟文件系统-文件系统-块 I/O -设备驱动-物理设备(参考：[Linux-storage-stack-diagram](https://www.google.com/search?q=Linux-storage-stack-diagram_v4.10&oq=Linux-storage-stack-diagram_v4.10&gs_lcrp=EgZjaHJvbWUyBggAEEUYOdIBBzU4M2owajeoAgCwAgA&sourceid=chrome&ie=UTF-8))。兼容取向的松耦合逻辑带来超长的软件调用栈，进而引入无法忽视的性能开销（参考：[OSDI '22 Best Paper: XRP](https://www.usenix.org/conference/osdi22/presentation/zhong)）。因此，目前科研前沿提出了不少绕过传统内核-文件系统体系（Kernel Bypass）的存储解决方案，如 SPDK 等。通过解耦权限控制面与数据传输面，在用户态完成高效数据传输，而不用经过冗长的内核存储栈。


## 参考资料

- [File Systems - OSDev](https://wiki.osdev.org/File_Systems)
- [rCore - fs implementation](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter6/index.html#)
- [FAT 和 UNIX 文件系统](https://jyywiki.cn/OS/2022/slides/27.slides.html#/)
- [Xv6 文件系统实现](https://jyywiki.cn/OS/2022/slides/29.slides.html#/)
- [你管这破玩意叫文件系统 - 微信科普公众号](https://mp.weixin.qq.com/s/q6OjwCXSk05TvX_BIu1M0g)
- [OSDI '22 Best Paper: XRP](https://www.usenix.org/conference/osdi22/presentation/zhong)
- [SPDKL: The Storage Performance Development Kit](https://spdk.io/doc/about.html)
- [存储系统-从没入门到刚入门](https://www.yuque.com/wwyf/blog/dhoobh)